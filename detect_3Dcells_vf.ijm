/* macro detect_3Dcells_vf.ijm
 *
 * this macro computes volume of 3D cells in a stack image
 * before launching this macro, the user should have launched cellpose on the 
 * stack image (each slice separately) and the detected ROIs should have been 
 * saved in a zip file with the image name followed by "_cellROIs_cellPose.zip"
 * 
 * The user is asked to draw rectangles around the cells of interest, then 
 * the macro shows the ROIs found by cellpose BUT they need corrections, the user
 * has to correct them and finally the volume and 3D cell are saved
 * 
 * 
 * by A-S MACE, tested on Fiji 1.53t on Windows
 */
roiManager("reset");
run("Close All");
run("Set Measurements...", "area mean centroid bounding redirect=None decimal=5");

// ending of the ROIs generated by cellpose
ending_ROIs = "_cellROIs_cellPose_cyto2_diam50.zip";

// asks the user to choose the image to treat
img_name = File.openDialog("Choose your image treated by CellPose");
run("Bio-Formats", "open=["+img_name+"] color_mode=Composite open_files open_all_series rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT");
tit_img = getTitle();
getDimensions(width, height, channels, slices, frames);
getVoxelSize(pixelWidth, pixelHeight, pixel_depth, unit);
dir_img = getDirectory("image");
name_noExt = substring(tit_img,0,lastIndexOf(tit_img,".")); // for saving

if ( !File.exists(dir_img+name_noExt+ending_ROIs) )
	exit("Exit of the macro: No cellpose file found");

// creates the results directory
dir_save = dir_img+"3D_crops_"+name_noExt+File.separator;
if( !File.exists(dir_save) ){
	File.makeDirectory(dir_save);
}

// adjusts vizualisation
selectWindow(tit_img);
Stack.setSlice(slices/2);
for (i_ch = 0; i_ch < channels; i_ch++) {
	Stack.setChannel(i_ch);
	run("Enhance Contrast", "saturated=0.35");
}

// asks the user to choose the slices to analyze and the minimal ROI size
Dialog.createNonBlocking("Choose slices & channel of analysis");
Dialog.addNumber("Cell channel",2);
Dialog.addNumber("Beginning slice", 1);
Dialog.addNumber("End slice", slices);
Dialog.addNumber("Smaller detection for cell (Âµm^2)",5);
Dialog.show();
cell_chan = Dialog.getNumber();
slice_beg = Dialog.getNumber();
slice_end = Dialog.getNumber();
min_size_cell = Dialog.getNumber(); 

// asks the user to draw the cells to analyze
setTool("rectangle");
waitForUser("Draw your cells of analysis (should contain the whole cell on all slices); add to the Manager");
roiManager("save", dir_img+name_noExt+"_ROIs_analysis.zip");
nb_ROIs_drawn = roiManager("count");

bx_DrawnROIs = newArray(nb_ROIs_drawn);
by_DrawnROIs = newArray(nb_ROIs_drawn);

run("Clear Results");
roiManager("measure");
for (i_res = 0; i_res < nResults; i_res++) {
	bx_DrawnROIs[i_res] = getResult("BX", i_res);
	by_DrawnROIs[i_res] = getResult("BY", i_res);
}

// opens cellPose ROIs
roiManager("reset");
roiManager("open", dir_img+name_noExt+ending_ROIs);

// creates the label image
selectWindow(tit_img);
run("Select All");
// ROIs to Label image requires a 1 channel image but will create another image
run("Duplicate...", "title=label duplicate channels=1");
run("ROIs to Label image");
run("16-bit");
label_image = getTitle();

selectWindow("label");
close();

// splits channels
selectWindow(tit_img);
run("Split Channels");
// re-merges the channels + the labels image
str_mergeCh = "";
for (i_ch = 0; i_ch < channels; i_ch++) 
	str_mergeCh = str_mergeCh+"c"+i_ch+1+"=[C"+i_ch+1+"-"+tit_img+"] ";
str_mergeCh = str_mergeCh+"c"+channels+1+"="+label_image+" create";
run("Merge Channels...", str_mergeCh);
merge_ch = getTitle();
selectWindow(merge_ch);
roiManager("show all");
roiManager("show none");

roiManager("reset");
volume_cells = newArray(nb_ROIs_drawn);
for (i_cell = 0; i_cell < nb_ROIs_drawn; i_cell++) { // for each cell separately
	roiManager("open", dir_img+name_noExt+"_ROIs_analysis.zip");
	selectWindow(merge_ch);
	// duplicates the channel with the cells
	roiManager("select", i_cell);
	run("Duplicate...", "title=Crop_cell"+i_cell+1+" duplicate channels="+cell_chan+" slices="+slice_beg+"-"+slice_end);
	selectWindow(merge_ch);
	roiManager("select", i_cell);
	// last channel = labels image
	run("Duplicate...", "title=Crop_cell"+i_cell+1+"_cellpose duplicate channels="+channels+1+" slices="+slice_beg+"-"+slice_end);
	run("Select All");
	run("Label image to ROIs");
	// removes the objects on the border
	excludeObjectsBorder("Crop_cell"+i_cell+1+"_cellpose",pixelWidth,min_size_cell);
	selectWindow("Crop_cell"+i_cell+1);
	roiManager("show all with labels");
	waitForUser("Correct the ROIs if necessary");
	
	// saves the crop and the ROIs inside
	selectWindow("Crop_cell"+i_cell+1);
	saveAs("tiff", dir_save+"Crop_cell"+i_cell+1+".tif");
	close();
	roiManager("deselect");
	roiManager("save", dir_save+"Crop_cell"+i_cell+1+"_ROIs.zip");
	
	// computes the volume
	run("Clear Results");
	roiManager("deselect");
	roiManager("measure");
	for (i_res = 0; i_res < nResults(); i_res++) 
		volume_cells[i_cell] += getResult("Area", i_res); 
	volume_cells[i_cell] *= pixel_depth;
	
	selectWindow("Crop_cell"+i_cell+1+"_cellpose");
	close();
	roiManager("reset");
}

// saves the final results
run("Clear Results");
for (i_cell = 0; i_cell < nb_ROIs_drawn; i_cell++) {
	setResult("Cell", i_cell, "Cell"+i_cell+1);
	setResult("Volume ("+unit+"^3)",i_cell,volume_cells[i_cell]);
}
saveAs("Results",dir_img+name_noExt+"_cellsVolumes.xls");

selectWindow(tit_img);
run("Select All");
run("Duplicate...", "title=cellZMask duplicate channels=1 slices="+slice_beg+"-"+slice_end);
run("Multiply...", "value=0 stack");
selectWindow("cellZMask");
nbRoi_bef = roiManager("count");
for (i_cell = 0; i_cell < nb_ROIs_drawn; i_cell++) {
	roiManager("open", dir_save+"Crop_cell"+i_cell+1+"_ROIs.zip");
	
	for (i = nbRoi_bef; i < roiManager("count"); i++) {
		roiManager("select", i);
		print(bx_DrawnROIs[i_cell]/pixelWidth, by_DrawnROIs[i_cell]/pixelWidth);
		RoiManager.translate(bx_DrawnROIs[i_cell]/pixelWidth, by_DrawnROIs[i_cell]/pixelWidth);
		run("Add...", "value="+i_cell+1+" slice");
	}
	nbRoi_bef = roiManager("count");
}

selectWindow("cellZMask");
Stack.setSlice(nSlices/2);
run("Fire");
roiManager("show all");
roiManager("show none");
resetMinAndMax();
saveAs("Tiff", dir_img+name_noExt+"_chosenCells_ZMask.tif");

// this function clears the objects that are on the border
function excludeObjectsBorder(img_name,pixelWidth,min_size_cell){
	selectWindow(img_name);
	getDimensions(width_crop, height_crop, channels_crop, slices_crop, frames_crop);
	
	run("Clear Results");
	roiManager("deselect");
	roiManager("measure");
	
	// removes the objects that are touching the border thanks to the bouding box
	for (i_res = nResults()-1; i_res >= 0 ; i_res--) {
	    if( getResult("BX", i_res) == 0 || getResult("BY", i_res) == 0 || getResult("BX", i_res)+getResult("Width", i_res) >= (width_crop-1)*pixelWidth || getResult("BY", i_res)+getResult("Height", i_res) >= (height_crop-1)*pixelWidth ){
	    	roiManager("select", i_res);
	    	roiManager("delete");
	    }
	}
	run("Clear Results");
	
	// creates a threhsolded image thanks to the ROIs
	selectWindow(img_name);
	run("Multiply...", "value=0 stack");
	run("ROIs to Label image");
	label_crop = getTitle();
	
	setThreshold(1, 10e10);
	run("Convert to Mask", "method=Default background=Dark black");
	roiManager("reset");
	run("Analyze Particles...", "size="+min_size_cell+"-Infinity exclude clear add stack");
	
	selectWindow(label_crop);
	close();
}
